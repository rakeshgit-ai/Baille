<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Braille Auto-Correct & Suggestion</title>
   <style>
    body {
        font-family: 'Segoe UI', Arial, sans-serif;
        margin: 0;
        background: linear-gradient(135deg, #fdf6e3 0%, #e0f7fa 100%);
        min-height: 100vh;
        color: #2d2d2d;
    }
    .container {
        max-width: 800px;
        margin: 40px auto 0 auto;
        background: #fff;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(60,60,120,0.10);
        padding: 36px 32px 32px 32px;
    }
    h1 {
        color: #ff7043;
        text-align: center;
        margin-bottom: 12px;
        letter-spacing: 2px;
        font-size: 2.2em;
        text-shadow: 0 2px 8px #ffe0b2;
    }
    label {
        font-weight: 600;
        color: #00897b;
    }
    input[type="text"], input[type="file"] {
        font-size: 1.1em;
        padding: 10px;
        border: 1.5px solid #b39ddb;
        border-radius: 6px;
        margin-top: 8px;
        margin-bottom: 12px;
        width: 100%;
        box-sizing: border-box;
        transition: border 0.2s;
        background: #f3e5f5;
        color: #4a148c;
    }
    input[type="text"]:focus {
        border-color: #ff7043;
        outline: none;
        background: #fffde7;
    }
    #parsedOutput {
        margin-top: 18px;
        font-size: 1.4em;
        color: #00897b;
        background: #e0f2f1;
        border-radius: 8px;
        padding: 10px 16px;
        min-height: 32px;
        box-shadow: 0 2px 8px rgba(0,150,136,0.07);
    }
    #suggestionsContainer {
        margin-top: 18px;
        background: #fce4ec;
        border-radius: 10px;
        padding: 12px 18px;
        box-shadow: 0 2px 8px rgba(233,30,99,0.08);
    }
    #suggestionsContainer h3 {
        margin: 0 0 8px 0;
        color: #ab47bc;
        font-size: 1.1em;
    }
    .suggestion-item {
        margin: 8px 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        background: #ffe0b2;
        border-radius: 6px;
        padding: 7px 14px;
        transition: background 0.2s, box-shadow 0.2s;
        box-shadow: 0 1px 4px rgba(255,112,67,0.06);
        color: #6d4c41;
    }
    .suggestion-item:hover {
        background: #ff7043;
        color: #fff;
    }
    .confidence-meter {
        width: 60px;
        height: 8px;
        background: #b2dfdb;
        border-radius: 4px;
        margin-left: 12px;
        overflow: hidden;
    }
    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, #ab47bc 0%, #ff7043 100%);
    }
    .alphabet-section {
        margin-top: 32px;
    }
    .alphabet-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        margin-bottom: 30px;
        justify-content: center;
    }
    .letter-item {
        border: 1.5px solid #ffb300;
        border-radius: 10px;
        padding: 10px 6px 8px 6px;
        width: 70px;
        text-align: center;
        background: #fffde7;
        transition: box-shadow 0.2s, border 0.2s;
        box-shadow: 0 2px 8px rgba(255,193,7,0.06);
    }
    .letter-item:hover {
        border-color: #ab47bc;
        box-shadow: 0 4px 16px rgba(171,71,188,0.13);
        background: #f3e5f5;
    }
    .letter-symbol {
        font-size: 1.6em;
        font-weight: bold;
        color: #ff7043;
    }
    .dot-pattern {
        display: grid;
        grid-template-columns: repeat(2, 14px);
        grid-template-rows: repeat(3, 14px);
        gap: 3px;
        justify-content: center;
        margin: 8px 0;
    }
    .dot {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #ffe0b2;
        border: 1px solid #ffb300;
        transition: background 0.2s;
    }
    .dot.active {
        background: #ab47bc;
        border-color: #ab47bc;
    }
    .key-combo {
        font-size: 0.95em;
        color: #00897b;
        margin-top: 2px;
    }
    .analytics {
        margin-top: 30px;
        font-size: 1em;
        color: #4a148c;
        background: #f3e5f5;
        border-radius: 8px;
        padding: 10px 18px;
        box-shadow: 0 2px 8px rgba(171,71,188,0.08);
    }
    .analytics span {
        display: inline-block;
        min-width: 70px;
        margin-right: 18px;
    }
    .dict-upload {
        margin-top: 22px;
        margin-bottom: 10px;
        background: #e0f2f1;
        border-radius: 8px;
        padding: 12px 18px;
        box-shadow: 0 2px 8px rgba(0,150,136,0.06);
    }
    #dictStatus {
        color: #ff7043;
        font-weight: 600;
        margin-left: 10px;
    }
    @media (max-width: 600px) {
        .container { padding: 12px 2vw; }
        .alphabet-grid { gap: 6px; }
        .letter-item { width: 48px; padding: 6px 2px 4px 2px; }
        .dot-pattern { grid-template-columns: repeat(2, 10px); grid-template-rows: repeat(3, 10px); }
        .dot { width: 10px; height: 10px; }
    }
</style>
</head>
<body>
    <div class="container">
        <h1>Braille Auto-Correct & Suggestion</h1>
        <div>
            <label for="brailleInput">Enter Braille (QWERTY) Patterns (space-separated):</label><br>
            <input type="text" id="brailleInput" autocomplete="off" style="width: 350px;" />
        </div>
        <div id="parsedOutput">Ready for input...</div>
        <div id="suggestionsContainer" style="display:none;">
            <h3>Suggestions:</h3>
            <div id="suggestionsList"></div>
        </div>
        <div class="alphabet-section">
            <h2>Braille Alphabet (QWERTY keys)</h2>
            <div class="alphabet-grid" id="alphabetGrid"></div>
        </div>
        <div class="analytics">
            <b>Analytics:</b>
            <span>Total Queries: <span id="totalQueries">0</span></span>
            <span>Avg. Response: <span id="avgResponseTime">0ms</span></span>
            <span>Cache Hits: <span id="cacheHits">0%</span></span>
            <span>Dictionary: <span id="dictionarySize">0</span> words</span>
        </div>
        <div class="dict-upload">
            <label for="dictFile">Load Dictionary File:</label>
            <input type="file" id="dictFile" accept=".txt" />
            <span id="dictStatus"></span>
        </div>
    </div>
    <script>
       // Braille patterns for each letter
const braillePatterns = {
    'A': { keys: 'D', dots: [1] },
    'B': { keys: 'DW', dots: [1, 2] },
    'C': { keys: 'DK', dots: [1, 4] },
    'D': { keys: 'DKO', dots: [1, 4, 5] },
    'E': { keys: 'DO', dots: [1, 5] },
    'F': { keys: 'DWK', dots: [1, 2, 4] },
    'G': { keys: 'DWKO', dots: [1, 2, 4, 5] },
    'H': { keys: 'DWO', dots: [1, 2, 5] },
    'I': { keys: 'WK', dots: [2, 4] },
    'J': { keys: 'WKO', dots: [2, 4, 5] },
    'K': { keys: 'DQ', dots: [1, 3] },
    'L': { keys: 'DWQ', dots: [1, 2, 3] },
    'M': { keys: 'DQK', dots: [1, 3, 4] },
    'N': { keys: 'DQKO', dots: [1, 3, 4, 5] },
    'O': { keys: 'DQO', dots: [1, 3, 5] },
    'P': { keys: 'DWQK', dots: [1, 2, 3, 4] },
    'Q': { keys: 'DWQKO', dots: [1, 2, 3, 4, 5] },
    'R': { keys: 'DWQO', dots: [1, 2, 3, 5] },
    'S': { keys: 'WQK', dots: [2, 3, 4] },
    'T': { keys: 'WQKO', dots: [2, 3, 4, 5] },
    'U': { keys: 'DQP', dots: [1, 3, 6] },
    'V': { keys: 'DWQP', dots: [1, 2, 3, 6] },
    'W': { keys: 'WKOP', dots: [2, 4, 5, 6] },
    'X': { keys: 'DQKP', dots: [1, 3, 4, 6] },
    'Y': { keys: 'DQKOP', dots: [1, 3, 4, 5, 6] },
    'Z': { keys: 'DQOP', dots: [1, 3, 5, 6] }
};

// Initialize the alphabet grid
function initializeAlphabetGrid() {
    const grid = document.getElementById('alphabetGrid');
    Object.entries(braillePatterns).forEach(([letter, pattern]) => {
        const item = document.createElement('div');
        item.className = 'letter-item';
        const symbol = document.createElement('div');
        symbol.className = 'letter-symbol';
        symbol.textContent = letter;
        const dotPattern = document.createElement('div');
        dotPattern.className = 'dot-pattern';
        for (let i = 1; i <= 6; i++) {
            const dot = document.createElement('div');
            dot.className = `dot dot-${i}`;
            if (pattern.dots.includes(i)) dot.classList.add('active');
            dotPattern.appendChild(dot);
        }
        const keyCombo = document.createElement('div');
        keyCombo.className = 'key-combo';
        keyCombo.textContent = pattern.keys;
        item.appendChild(symbol);
        item.appendChild(dotPattern);
        item.appendChild(keyCombo);
        grid.appendChild(item);
    });
}

// Convert key combinations to letters
function parseKeyToLetter(keys) {
    const normalizedKeys = keys.toUpperCase().split('').sort().join('');
    for (const [letter, pattern] of Object.entries(braillePatterns)) {
        const patternKeys = pattern.keys.split('').sort().join('');
        if (normalizedKeys === patternKeys) return letter;
    }
    return '?';
}

// Sample dictionary file content (add more words as needed)
const defaultDictionaryText = `
the
and
for
are
but
not
you
all
can
her
was
one
our
had
have
what
were
they
we
been
has
their
said
each
which
she
do
how
will
up
other
about
out
many
then
them
these
so
some
time
very
when
much
new
would
there
write
like
where
right
see
him
two
more
go
no
way
could
my
than
first
water
long
little
who
oil
sit
now
find
down
day
did
get
come
made
may
part
cat
dog
bat
rat
mat
sat
pat
hat
world
hello
braille
suggestion
input
test
home
house
mouse
car
bar
jar
far
star
start
cart
part
heart
hard
hand
sand
land
band
sand
send
bend
tend
tend
tend
tend
`;

// Load default dictionary
let dictionary = defaultDictionaryText
    .split(/\r?\n/)
    .map(w => w.trim().toUpperCase())
    .filter(w => w.length > 0);

// Levenshtein distance for fuzzy search
function levenshteinDistance(str1, str2) {
    const matrix = [];
    for (let i = 0; i <= str2.length; i++) matrix[i] = [i];
    for (let j = 0; j <= str1.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    return matrix[str2.length][str1.length];
}

// BK-tree implementation for fast fuzzy search
class BKTreeNode {
    constructor(word) {
        this.word = word;
        this.children = {};
    }
}

class BKTree {
    constructor(distanceFn) {
        this.root = null;
        this.distanceFn = distanceFn;
    }

    add(word) {
        if (!this.root) {
            this.root = new BKTreeNode(word);
            return;
        }
        let node = this.root;
        while (true) {
            const dist = this.distanceFn(word, node.word);
            if (dist === 0) return; // already exists
            if (!node.children[dist]) {
                node.children[dist] = new BKTreeNode(word);
                return;
            }
            node = node.children[dist];
        }
    }

    search(word, maxDist) {
        const results = [];
        function recursiveSearch(node) {
            const dist = node.word ? this.distanceFn(word, node.word) : 0;
            if (dist <= maxDist) results.push({ word: node.word, distance: dist });
            for (let d = dist - maxDist; d <= dist + maxDist; d++) {
                if (d >= 0 && node.children[d]) {
                    recursiveSearch.call(this, node.children[d]);
                }
            }
        }
        if (this.root) recursiveSearch.call(this, this.root);
        return results;
    }
}

let bkTree = null;
function buildBKTree() {
    bkTree = new BKTree(levenshteinDistance);
    dictionary.forEach(word => bkTree.add(word));
}

// Use BK-tree for fast suggestions
function getSuggestions(word, maxSuggestions = 3) {
    if (!bkTree || word.length < 2) return [];
    const results = bkTree.search(word.toUpperCase(), 2)
        .map(item => ({
            word: item.word,
            distance: item.distance,
            confidence: Math.max(0, 100 - (item.distance * 25))
        }))
        .filter(item => item.confidence > 25)
        .sort((a, b) => a.distance - b.distance || b.confidence - a.confidence)
        .slice(0, maxSuggestions);
    return results;
}

// Analytics tracking
let analytics = {
    totalQueries: 0,
    totalResponseTime: 0,
    cacheHits: 0,
    cache: new Map()
};

// Update analytics display
function updateAnalytics() {
    document.getElementById('totalQueries').textContent = analytics.totalQueries;
    document.getElementById('avgResponseTime').textContent = 
        analytics.totalQueries > 0 ? 
        Math.round(analytics.totalResponseTime / analytics.totalQueries) + 'ms' : '0ms';
    document.getElementById('cacheHits').textContent = 
        analytics.totalQueries > 0 ? 
        Math.round((analytics.cacheHits / analytics.totalQueries) * 100) + '%' : '0%';
    document.getElementById('dictionarySize').textContent = dictionary.length;
}

// Process input and show results
function processInput() {
    const startTime = performance.now();
    const input = document.getElementById('brailleInput').value.trim();
    const outputDiv = document.getElementById('parsedOutput');
    const suggestionsContainer = document.getElementById('suggestionsContainer');
    const suggestionsList = document.getElementById('suggestionsList');

    analytics.totalQueries++;

    if (!input) {
        outputDiv.textContent = 'Ready for input...';
        suggestionsContainer.style.display = 'none';
        return;
    }

    // Check cache first
    if (analytics.cache.has(input)) {
        analytics.cacheHits++;
        const cached = analytics.cache.get(input);
        outputDiv.textContent = cached.parsed;
        showSuggestions(cached.suggestions);
    } else {
        // Parse the input
        const patterns = input.split(' ').filter(p => p.length > 0);
        const parsedLetters = patterns.map(pattern => parseKeyToLetter(pattern));
        const parsedWord = parsedLetters.join('');

        outputDiv.textContent = parsedWord || 'Invalid pattern';

        // Get suggestions if there are unrecognized patterns
        let suggestions = [];
        if (parsedWord && parsedWord.includes('?')) {
            const cleanWord = parsedWord.replace(/\?/g, '');
            if (cleanWord.length > 0) {
                suggestions = getSuggestions(cleanWord);
            }
        } else if (parsedWord && parsedWord.length > 1) {
            suggestions = getSuggestions(parsedWord);
        }

        // Cache the result
        analytics.cache.set(input, { parsed: parsedWord, suggestions });
        showSuggestions(suggestions);
    }

    const endTime = performance.now();
    analytics.totalResponseTime += (endTime - startTime);
    updateAnalytics();
}

// Show autocorrect suggestions
function showSuggestions(suggestions) {
    const suggestionsContainer = document.getElementById('suggestionsContainer');
    const suggestionsList = document.getElementById('suggestionsList');

    if (suggestions.length === 0) {
        suggestionsContainer.style.display = 'none';
        return;
    }

    suggestionsContainer.style.display = 'block';
    suggestionsList.innerHTML = '';

    suggestions.forEach(suggestion => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.onclick = () => applySuggestion(suggestion.word);

        const word = document.createElement('span');
        word.textContent = suggestion.word;
        word.style.fontWeight = '600';

        const meter = document.createElement('div');
        meter.className = 'confidence-meter';
        
        const fill = document.createElement('div');
        fill.className = 'confidence-fill';
        fill.style.width = suggestion.confidence + '%';
        
        meter.appendChild(fill);

        item.appendChild(word);
        item.appendChild(meter);
        suggestionsList.appendChild(item);
    });
}

// Apply a suggestion
function applySuggestion(word) {
    document.getElementById('parsedOutput').textContent = word;
    document.getElementById('suggestionsContainer').style.display = 'none';
}

// Initialize everything when the page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeAlphabetGrid();
    buildBKTree();
    updateAnalytics();
    document.getElementById('brailleInput').addEventListener('input', processInput);
    document.getElementById('dictFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            // Split by line, remove empty lines, uppercase for consistency
            dictionary = evt.target.result
                .split(/\r?\n/)
                .map(w => w.trim().toUpperCase())
                .filter(w => w.length > 0);
            analytics.cache.clear(); // Clear cache on dictionary load
            buildBKTree(); // Rebuild BK-tree with new dictionary
            document.getElementById('dictStatus').textContent = `Loaded ${dictionary.length} words.`;
            updateAnalytics();
        };
        reader.readAsText(file);
    });
    // Add example after load
    setTimeout(() => {
        document.getElementById('brailleInput').value = 'D DWQ DWQ DWQKO';
        processInput();
    }, 1000);
});
    </script>
</body>
</html>